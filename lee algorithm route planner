//the lee algorithm code was already given so this references to that
#include "leelib.c"
#include <stdio.h>



int target_cell[2], start_cell[2];
//the maze route given in matrix form in which -1 represents the blocked way and 0 the way that is free to pass
int m[13][13] = {{-1,-1,-1,-1,0,-1,0,-1,0,-1,-1,-1,-1},
                    {-1,-1,-1,-1,0,-1,0,-1,0,-1,-1,-1,-1},
                    {-1,-1,0,0,0,0,0,0,0,0,0,-1,-1},
                    {-1,-1,0,-1,0,-1,0,-1,0,-1,0,-1,-1},
                    {0,0,0,0,0,0,0,0,0,0,0,0,0},
                    {-1,-1,0,-1,0,-1,0,-1,0,-1,0,-1,-1},
                    {0,0,0,0,0,0,0,0,0,0,0,0,0},
                    {-1,-1,0,-1,0,-1,0,-1,0,-1,0,-1,-1},
                    {0,0,0,0,0,0,0,0,0,0,0,0,0},
                    {-1,-1,0,-1,0,-1,0,-1,0,-1,0,-1,-1},
                    {-1,-1,0,0,0,0,0,0,0,0,0,-1,-1},
                    {-1,-1,-1,-1,0,-1,0,-1,0,-1,-1,-1,-1},
                    {-1,-1,-1,-1,0,-1,0,-1,0,-1,-1,-1,-1}};

void matrixgenerator(){
 int edgeAmount, z, edgeX, edgeY, stationX1, stationY1, stationX2, stationY2;
   scanf("%d",&edgeAmount);

   for(z = 0; z < edgeAmount; z++){
      readEdge(&edgeX,&edgeY);
      m[edgeX][edgeY] = -1;
   }
   readStation(&stationX1, &stationY1); // reads the starting cell and stores it into a list
   start_cell[0] = stationX1;
   start_cell[1] = stationY1;
      readStation(&stationX2, &stationY2); // reads the target cell and stores it into a list

   target_cell[0] = stationX2;
   target_cell[1] = stationY2;
   
      



}
// the for-if loop that checks its place in the maze
int main(){
     matrixgenerator();
    int v = 1;

   m[target_cell[0]][target_cell[1]] = v;
   int loop_continue = 1;
   int i, j;
   while(loop_continue == 1){

   for(i = 0; i < 13; i++){
      for(j = 0; j < 13; j++){
         if(m[i][j] == v){
             if (i - 1 >= 0 && m[i-1][j] == 0) {
               m[i - 1][j] = v + 1; // Check cell above
                }
             if (i + 1 < 13 && m[i+1][j] == 0) {
               m[i + 1][j] = v + 1; // Check cell below
                  }
             if (j - 1 >= 0 && m[i][j-1] == 0) {
               m[i][j - 1] = v + 1; // Check cell to the left
                  }
             if (j + 1 < 13 && m[i][j+1] == 0) {
               m[i][j + 1] = v + 1; // Check cell to the right
               }

             if(i == start_cell[0] && j == start_cell[1]){ // have to look at how the start cell will be assigned
                  loop_continue = 0;
                   }
             
            
            }
        
        
        }
    
    }
    v = v + 1;
    
}
int current_cell[2];
   int loop_continue2 = 1;
   current_cell[0] = start_cell[0];
   current_cell[1] = start_cell[1];
   while(loop_continue2 == 1){
      if(current_cell[0] == target_cell[0] && current_cell[1] == target_cell[1]){
         loop_continue2 = 0;
         break; 
      }
      else{ if(current_cell[0] - 1 < 0 &&m[current_cell[0] - 1][current_cell[1]] < m[current_cell[0]][current_cell[1]]&& m[current_cell[0]-1][current_cell[1]] >= 1) {
              current_cell[0] = current_cell[0] - 1; // Check cell above
              if(current_cell[0] == target_cell[0] && current_cell[1] == target_cell[1]){
         break; }
              printCrossingName(current_cell[0], current_cell[1]);
                }
       if (current_cell[0] + 1 < 13 && m[current_cell[0] + 1][current_cell[1]] < m[current_cell[0]][current_cell[1]]&&m[current_cell[0]-1][current_cell[1]] >= 1) {
               current_cell[0] = current_cell[0] + 1; // Check cell below
               if(current_cell[0] == target_cell[0] && current_cell[1] == target_cell[1]){
         loop_continue2 = 0;
         break; }
               printCrossingName(current_cell[0], current_cell[1]);
                  }
        if (current_cell[1] - 1 >= 0 &&m[current_cell[0]][current_cell[1]-1] < m[current_cell[0]][current_cell[1]]&& m[current_cell[0]][current_cell[1]-1] >= 1) {
               current_cell[1] = current_cell[1] - 1; // Check cell to the left
               if(current_cell[0] == target_cell[0] && current_cell[1] == target_cell[1]){
         loop_continue2 = 0;
         break; }
               printCrossingName(current_cell[0], current_cell[1]);
                  }
        if (current_cell[1] + 1 < 13 &&m[current_cell[0]][current_cell[1]+1] < m[current_cell[0]][current_cell[1]]&& m[current_cell[0]][current_cell[1]+1] >= 0) {
               current_cell[1] = current_cell[1] + 1; // Check cell to the right
               if(current_cell[0] == target_cell[0] && current_cell[1] == target_cell[1]){
         loop_continue2 = 0;
         break; }
               printCrossingName(current_cell[0], current_cell[1]); 
              }

}
   }
printf("\n");
printMatrix(m);
    return 0;
}
